# Charter Backend 项目架构开发规范

## 1. 项目概述

Charter Backend 是一个基于 Spring Boot 3.x 的个人网站项目，采用领域驱动设计（DDD）和分层架构模式。

**技术栈**：Java 17 + Spring Boot 3.4.5 + MyBatis Plus 3.5.8 + MySQL 8.0 + Redis 6.0

## 2. 技术架构

### 2.1 整体架构设计

项目采用**多模块分层架构**，遵循**领域驱动设计（DDD）**思想，实现了清晰的职责分离和依赖解耦。

```
charter-backend-parent/
├── charter-app/                    # 应用启动模块
├── charter-dependencies/            # 依赖版本管理
├── charter-common/                  # 基础设施层
│   ├── charter-common-core/         # 核心工具
│   ├── charter-common-web/          # Web配置
│   ├── charter-common-security/     # 安全认证
│   ├── charter-common-mybatis/      # 数据库配置
│   ├── charter-common-redis/        # 缓存配置
│   ├── charter-common-rabbitmq/     # 消息队列
│   ├── charter-common-file/         # 文件服务
│   ├── charter-common-log/          # 日志管理
│   ├── charter-common-mail/         # 邮件服务
│   └── charter-common-job/          # 定时任务
├── charter-domain/                  # 领域层
│   └── charter-domain-admin/        # 管理域
│       ├── charter-domain-admin-api/    # 领域接口
│       └── charter-domain-admin-core/   # 领域实现
└── charter-server/                  # 应用服务层
    └── charter-server-admin/        # 管理服务
```

### 2.2 分层架构说明

#### 2.2.1 应用启动层（charter-app）
- **职责**：项目启动入口，依赖聚合
- **特点**：
  - 包含 Spring Boot 主启动类
  - 聚合所有业务模块依赖
  - 负责最终的 JAR 包构建

#### 2.2.2 基础设施层（charter-common）
- **职责**：提供技术支持，不包含业务逻辑
- **原则**：
  - 不依赖任何业务模块或领域模块
  - 只提供技术组件和工具类
  - 可被其他层复用

#### 2.2.3 领域层（charter-domain）
- **职责**：核心业务逻辑和领域模型
- **设计原则**：
  - **API模块**：包含接口定义、领域模型、DTO、VO等，不依赖任何其他模块
  - **Core模块**：实现领域接口，封装业务逻辑
  - 遵循 Repository 模式进行数据访问

#### 2.2.4 应用服务层（charter-server）
- **职责**：对外提供 REST API，协调领域服务
- **特点**：
  - 包含 Controller、Service 等
  - 依赖领域层接口，不直接依赖实现
  - 负责数据转换和业务流程编排

## 3. 设计思想与原则

### 3.1 核心设计思想

#### 3.1.1 领域驱动设计（DDD）
- **聚合根**：以业务实体为中心组织代码
- **仓储模式**：通过 Repository 接口抽象数据访问
- **领域服务**：封装复杂的业务逻辑

#### 3.1.2 依赖倒置原则
- 高层模块不依赖低层模块，都依赖抽象
- Service 层依赖 Repository 接口，而非具体实现
- 通过接口实现模块间的解耦

#### 3.1.3 单一职责原则
- 每个模块职责明确，边界清晰
- 基础设施层只提供技术支持
- 领域层专注业务逻辑
- 应用层负责协调和对外服务

## 4. 开发规范

### 4.1 模块依赖规范

#### 4.1.1 依赖方向
```
charter-app
    ↓
charter-server-*
    ↓
charter-domain-*-api
    ↑
charter-domain-*-core
    ↓
charter-common-*
```

#### 4.1.2 依赖原则
- **charter-app**：只依赖 server 模块和 domain-core 模块
- **charter-server-***：只依赖对应的 domain-api 模块和 common 模块
- **charter-domain-*-api**：不依赖任何其他业务模块
- **charter-domain-*-core**：依赖对应的 api 模块和 common 模块
- **charter-common-***：不依赖任何业务模块

### 4.2 代码结构规范

#### 4.2.1 包命名规范
```
ink.charter.website
├── common.*                 # 基础设施
├── domain.*.api.*          # 领域接口
├── domain.*.core.*         # 领域实现
└── server.*.*              # 应用服务
```

#### 4.2.2 类命名规范
- **Controller**：以 `Controller` 结尾
- **Service**：接口以 `Service` 结尾，实现类以 `ServiceImpl` 结尾
- **Repository**：接口以 `Repository` 结尾，实现类以 `RepositoryImpl` 结尾
- **Entity**：以 `Entity` 结尾
- **DTO**：以 `DTO` 结尾
- **VO**：以 `VO` 结尾
- **Converter**：以 `Converter` 结尾

### 4.3 分层职责规范

#### 4.3.1 Controller层
- **职责**：接收HTTP请求，参数校验，调用Service，返回响应
- **规范**：
  - 使用 `@RestController` 注解
  - 使用 `@RequestMapping` 定义路径
  - 使用 Swagger 注解生成API文档
  - 不包含业务逻辑，只做参数转换和结果封装

```java
@RestController
@RequestMapping("/api/admin/users")
@Tag(name = "用户管理", description = "用户相关接口")
public class UserController {
    
    private final UserService userService;
    
    @PostMapping
    @Operation(summary = "创建用户")
    public Result<UserVO> createUser(@Valid @RequestBody CreateUserDTO dto) {
        // 参数转换 -> 调用服务 -> 结果转换
    }
}
```

#### 4.3.2 Service层
- **职责**：业务流程编排，调用Repository，事务管理
- **规范**：
  - 接口定义在 server 模块
  - 实现类使用 `@Service` 注解
  - 使用 `@Transactional` 管理事务
  - 依赖 Repository 接口，不直接操作数据库

```java
@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {
    
    private final SysUserRepository sysUserRepository;
    
    @Override
    @Transactional
    public void createUser(CreateUserDTO dto) {
        // 业务逻辑处理
        // 调用Repository
    }
}
```

#### 4.3.3 Repository层
- **职责**：数据访问抽象，封装数据库操作
- **规范**：
  - 接口定义在 domain-api 模块
  - 实现类在 domain-core 模块，使用 `@Repository` 注解
  - 封装复杂查询逻辑
  - 不包含业务逻辑

```java
// 接口定义（domain-api）
public interface SysUserRepository {
    void save(SysUserEntity user);
    SysUserEntity findById(Long id);
    List<SysUserEntity> findByCondition(UserQueryCondition condition);
}

// 实现类（domain-core）
@Repository
@RequiredArgsConstructor
public class SysUserRepositoryImpl implements SysUserRepository {
    
    private final SysUserMapper sysUserMapper;
    
    @Override
    public void save(SysUserEntity user) {
        // 数据库操作
    }
}
```

### 4.4 数据传输对象规范

#### 4.4.1 DTO（Data Transfer Object）
- **用途**：Controller 接收前端数据
- **位置**：domain-api 模块的 dto 包
- **规范**：
  - 使用 Bean Validation 注解进行参数校验
  - 字段命名使用驼峰命名法
  - 提供必要的 getter/setter 方法

```java
@Data
public class CreateUserDTO {
    @NotBlank(message = "用户名不能为空")
    private String username;
    
    @Email(message = "邮箱格式不正确")
    private String email;
}
```

#### 4.4.2 VO（View Object）
- **用途**：Controller 返回给前端的数据
- **位置**：domain-api 模块的 vo 包
- **规范**：
  - 只包含前端需要的字段
  - 敏感信息不暴露（如密码）
  - 所有vo类的Long类型都需要通过@JsonSerialize(using = ToStringSerializer.class)序列化成String类型返回给前端，避免精度丢失

```java
@Data
public class UserVO {
    private Long id;
    private String username;
    private String email;
    private LocalDateTime createTime;
}
```

#### 4.4.3 Entity
- **用途**：数据库实体映射
- **位置**：charter-domain-*-api 模块
- **规范**：
  - 使用 MyBatis Plus 注解
  - 字段与数据库表字段对应

```java
@Data
@TableName("sys_user")
public class SysUserEntity {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    
    private String username;
    private String password;
    private String email;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
}
```

### 4.5 数据库设计规范

#### 4.5.1 逻辑删除与唯一索引

项目使用逻辑删除（`is_deleted` 字段），在有唯一性约束的表中，需要使用 **MySQL 8.0+ 函数索引** 来避免删除后无法重复插入相同数据的问题。

**单字段唯一索引：**
```sql
-- 错误写法（会导致逻辑删除后无法插入相同数据）
UNIQUE KEY `uk_username` (`username`)

-- 正确写法（只对未删除记录生效）
UNIQUE KEY `uk_username` ((CASE WHEN `is_deleted` = 0 THEN `username` END))
```

**多字段唯一索引：**
```sql
-- 错误写法
UNIQUE KEY `uk_user_role` (`user_id`, `role_id`)

-- 正确写法（使用 CONCAT 拼接多个字段）
UNIQUE KEY `uk_user_role` ((CASE WHEN `is_deleted` = 0 THEN CONCAT(`user_id`, '-', `role_id`) END))
```

**原理说明：**
- 函数索引只对 `is_deleted = 0` 的记录生效
- 已删除的记录（`is_deleted = 1`）返回 NULL，不参与唯一性校验
- 允许多次插入相同数据，只要之前的记录已被逻辑删除

**注意事项：**
- 需要 MySQL 8.0.13 及以上版本
- 函数索引会略微影响写入性能，但对查询性能影响很小
- 所有关联表（如 `sys_user_role`、`sys_role_menu`）都需要使用此方式

### 4.6 对象转换规范

使用 MapStruct 进行对象转换：

```java
@Mapper(componentModel = "spring")
public interface UserConverter {
    
    SysUserEntity toEntity(CreateUserDTO dto);
    
    UserVO toVO(SysUserEntity entity);
    
    List<UserVO> toVOList(List<SysUserEntity> entities);
}
```

### 4.7 异常处理规范

#### 4.7.1 全局异常处理
- 使用 `@ControllerAdvice` 统一处理异常
- 定义业务异常类型
- 返回统一的错误响应格式

#### 4.7.2 业务异常
```java
public class BusinessException extends RuntimeException {
    private final String code;
    private final String message;
}
```

### 4.8 日志规范

#### 4.8.1 日志级别
- **ERROR**：系统错误，需要立即处理
- **WARN**：警告信息，需要关注
- **INFO**：重要的业务流程信息
- **DEBUG**：调试信息，生产环境关闭

#### 4.8.2 日志格式
```java
@Slf4j
public class UserServiceImpl {
    
    public void createUser(CreateUserDTO dto) {
        log.info("开始创建用户，用户名：{}", dto.getUsername());
        try {
            // 业务逻辑
            log.info("用户创建成功，ID：{}", user.getId());
        } catch (Exception e) {
            log.error("用户创建失败，用户名：{}", dto.getUsername(), e);
            throw e;
        }
    }
}
```

### 4.9 安全规范

#### 4.9.1 认证授权
- 使用 JWT 进行身份认证
- 使用 Spring Security 进行权限控制
- 敏感接口添加权限注解

```java
@PreAuthorize("hasRole('ADMIN')")
@PostMapping("/users")
public Result<UserVO> createUser(@RequestBody CreateUserDTO dto) {
    // 只有管理员可以创建用户
}
```

#### 4.9.2 数据安全
- 密码使用 BCrypt 加密
- 敏感信息不记录日志
- SQL 注入防护（使用 MyBatis 参数化查询）

## 5. 环境要求

- JDK 17+
- MySQL 8.0.13+（需要支持函数索引）
- Redis 6.0+
- RabbitMQ 3.8+

## 6. Git 提交规范

提交格式：`type(scope): subject`

类型说明：
- **feat**：新功能
- **fix**：修复bug
- **docs**：文档更新
- **refactor**：重构
- **style**：代码格式调整